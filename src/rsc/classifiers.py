# -*- coding: utf-8 -*-

import struct
from tools import split_bits, print_hex, strip_0


class OBJECT_TYPE(object):
    LINE = 'LINE'
    VECTOR = 'VECTOR'
    AREA = 'AREA'
    POINT = 'POINT'
    LABEL = 'LABEL'
    LABEL_TEMPLATE = 'LABEL_TEMPLATE'


class RscClassifierObject(object):

    def __init__(self):
        self.errors = []
        self.id = None
        self.connected_labels = []

    @staticmethod
    def parse(data):
        record = RscClassifierObject()
        record.parse_record(data)
        return record

    def info(self):
        print u'Classifier Object %s <%s> "%s"' % (
            self.id,
            self.short_name,
            self.name,
        )

    def parse_record(self, data):
        # print_hex(data)
        # Назначение поля Смещение    Длина   Комментарий
        # Длина записи объекта    0   4   В байтах
        self.full_length = struct.unpack('<I', data[0:4])[0]

        # Классификационный код   4   4
        self.classifier_code = struct.unpack('<I', data[4:8])[0]

        # Внутренний код объекта  8   4   "Порядковый номер объекта (может меняться) (с 1)"
        self.internal_code = struct.unpack('<I', data[8:12])[0]

        # Идентификационный код   12  4   Неизменяемый уникальный номер объекта
        self.id = struct.unpack('<I', data[12:16])[0]

        # Короткое имя объекта    16  32  Уникальное символьное имя (ANSI)
        self.short_name = strip_0(struct.unpack('<32s', data[16:48])[0]).decode('cp1251')

        # Название    48  32  ANSI
        self.name = strip_0(struct.unpack('<32s', data[48:80])[0]).decode('cp1251')

        # Характер локализации    80  1
        # 0х00 - линейный,
        # 0х01 – площадной,
        # 0х02 – точечный,
        # 0х03 – подпись,
        # 0х04 - векторный (точечный ориентированный объект, содержит две точки в   метрике),
        # 0x05 - шаблон подписи (первая точка метрики является точкой привязки шаблона, метрика подобъектов задает расположение подписей и вспомогательных  линий).
        localization = struct.unpack('<B', data[80:81])[0]
        self.localization = {
            0x00: OBJECT_TYPE.LINE,
            0x01: OBJECT_TYPE.AREA,
            0x02: OBJECT_TYPE.POINT,
            0x03: OBJECT_TYPE.LABEL,
            0x04: OBJECT_TYPE.VECTOR,
            0x05: OBJECT_TYPE.LABEL_TEMPLATE,
        }[localization]

        # Номер слоя (сегмента)   81  1   Число от 0 до 255
        # Признак масштабируемости    82  1   "0 - условный знак объекта не масштабируемый; 1 - знак масштабируется;"
        self.segment, self.is_scalable = struct.unpack('<BB', data[81:83])

        # Нижняя граница видимости    83  1   Число от 0 до 15 (N1)
        # Верхняя граница видимости   84  1   "Число от 0 до 15 (15 – N2)"
        self.visibility = struct.unpack('<BB', data[83:85])

        # Расширение локализации  85  1   "1 - при создании линейных объектов учитывать две точки метрики 0 – все точки метрики"
        self.localization_extention = struct.unpack('<B', data[85:86])[0]

        # Направление цифрования  86  1
        # 0x00-произвольное,
        # 0x01-определенное,
        # 0х02-объект справа,
        # 0x04-объект слева.

        # Для площадных объектов возможны направления цифрования объект слева (обход объекта против часовой стрелки: используется для водоемов и углублений рельефа) и объект  справа (обход объекта по часовой стрелке).
        # Для линейных объектов можно определенное (для тех объектов, для которых имеет смысл различать начало и конец метрики, например реки, цифруются от истока к устью) и произвольное для всех  остальных случаев.
        # Точечные объекты имеют только произвольное направление цифрования.
        # Все остальные произвольное или определенное.
        # Связанные подписи объектов предназначены для нанесения на карту  подписей по   семантическим характеристикам объекта, определенным видом шрифта. Шрифт выбирается из существующих  подписей классификатора.
        self.digitize_direction = struct.unpack('<B', data[86:87])[0]

        # Отображение с учетом семантики  87  1   1- для объектов с внешним видом пользователя, учитывающих семантику
        self.display_with_semantic = struct.unpack('<B', data[87:88])[0]

        # Номер расширения    88  2   Для объектов из серии – номер объекта в серии, для остальных 0.
        self.object_number = struct.unpack('<h', data[88:90])[0]

        # Количество связанных подписей   90  1   Число от 0 до 16
        self.connected_label_count = struct.unpack('<B', data[90:91])[0]

        # Признак сжатия объекта  91  1   "Возможность сжатия объекта при уменьшении масштаба 1 – не сжимать"
        self.compressable = struct.unpack('<B', data[91:92])[0]

        # Максимальное увеличение 92  1   "Максимальное увеличение объекта (от 1 до 25.0 раз) Значения от 0 до 250"
        self.max_scale = struct.unpack('<B', data[92:93])[0]

        # Максимальное уменьшение 93  1   "Максимальное уменьшение объекта (от 1 до 25.0 раз) Значения от 0 до 250"
        self.min_scale = struct.unpack('<B', data[93:94])[0]

        # Флаг включения границ   94  1   Флаг включения границ видимости
        self.is_view_borders = struct.unpack('<B', data[94:95])[0]

        # Резерв  95  1

        idx = 96
        for i in xrange(self.connected_label_count):
            label = {}
            # Связанная подпись объекта определяет шрифт, предназначенный для нанесения подписей объекта, текст которых содержится в качестве семантической характеристики этого объекта.
            # Описание связанных подписей имеет следующий вид:

            # Назначение поля Смещение    Длина   Комментарий
            # Идентификационный код связанной подписи 0   4   Неизменяемый уникальный номер подписи
            # Классификационный код семантики 4   4   Код семантики объекта, содержащей текст подписи
            # Постоянный префикс для подписи  8   7   В байтах
            # Количество десятичных знаков после запятой  15  1   Используется при печати подписи
            label['label_id'], label['semantic_id'], label['prefix'], label['decimal_points'] = struct.unpack('<II7sB', data[idx:idx + 16])
            idx += 16
            # ИТОГО: 16 байт

            self.connected_labels.append(label)

